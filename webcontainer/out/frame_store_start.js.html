<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: frame/store/start.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: frame/store/start.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
import React from 'react';
import ReactDom from 'react-dom';

import {
	createStore,
	applyMiddleware,
	combineReducers
} from 'redux';

import reduxAsync from './redux-async';

import {
	Provider
} from 'react-redux';


function start({root, component, model}) {

	let models = {};
	// model设置可以是数组和对象，最终根据model里的name属性拼接成键值对
	let modelType = Object.prototype.toString.call(model);

	if(modelType === '[object Array]') {
		model.map((item) => {
			models[item.name] = item
		});
	}
	else if(modelType === '[object Object]') {
		models = {
			[model.name]: model
		};
	}


	// 需要根据module里的方法动态拼接出reducer
	let reducers = {};
	// 需要存储异步的方法
	let asyncMethods = {};

	Object.keys(models).map((item) => {
		// 将异步方法存储上
		asyncMethods[item] = models[item].async;

		// 此处动态生成reducer
		// redux的初始值是model里配置的data
		reducers[item] = (state = models[item].data, action) => {
			let actionType = action.type;
			// 需要过滤掉redux自身内部的action
			let ifHasPlaceName = actionType.indexOf('/') >= 0 &amp;&amp; actionType.indexOf('@redux') &lt; 0;
			// 因为action的type是由module.name和方法名称组成，所以需要拆分已得到方法名
			let fieldName = actionType.split('/')[0];
			let methodName = actionType.split('/')[1];

			let syncMethod = null;

			// 如果不是redux自身的action，并且type书写符合规范
			// 就将对应方法赋值给syncMethod变量
			if(ifHasPlaceName) {
				syncMethod = models[fieldName].sync[methodName];
			}
			else {
				// 如果是书写不符合规范，则认为他直接使用了sync方法名字作为action.type
				// 那么就直接调用sync里的方法
				syncMethod = (typeof models[item] === 'object' &amp;&amp; models[item] !== null)
					? models[item].sync[action.type]
					: null;
			}

			// 如果有同步方法就调用
			if(syncMethod) {
				return syncMethod(state, action.payload);
			}
			else {
				return state;
			}
		}
	});

	// 调用redux的combine方法合并reducer
	// 同时调用异步中间件，把异步方法传入进去
	const store = createStore(combineReducers(reducers), applyMiddleware(reduxAsync(asyncMethods)));

	// 利用react-redux的Provider生成容器组件
	const Wrapper = () => {
		return (
			&lt;Provider store={store}>
				{component}
			&lt;/Provider>
		);
	};


	// 渲染
	ReactDom.render(&lt;Wrapper/>, root);

	return store;
}


export default start;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Header.html">Header</a></li><li><a href="Maybe.html">Maybe</a></li><li><a href="orgRefer.html">orgRefer</a></li><li><a href="Pagination.html">Pagination</a></li></ul><h3>Global</h3><ul><li><a href="global.html#allCheckTable">allCheckTable</a></li><li><a href="global.html#data">data</a></li><li><a href="global.html#dealHeader">dealHeader</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#fixedCol">fixedCol</a></li><li><a href="global.html#formatSelectData">formatSelectData</a></li><li><a href="global.html#getCookie">getCookie</a></li><li><a href="global.html#handleQueryRefer">handleQueryRefer</a></li><li><a href="global.html#handleTableChangeColor">handleTableChangeColor</a></li><li><a href="global.html#snCreateUIDom">snCreateUIDom</a></li><li><a href="global.html#sortBtns">sortBtns</a></li><li><a href="global.html#transRadio">transRadio</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Thu Mar 21 2019 10:52:14 GMT+0800 (GMT+08:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
